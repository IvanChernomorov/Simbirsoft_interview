# Подготовка к собеседованию

## Содержание

### Ручное тестирование.

1. [QA QC Тестирование](#1-qa-qc-тестирование) 
2. [Что такое тестирование](#2-что-такое-тестирование)
3. [Принципы тестирования](#3-принципы-тестирования)
4. [Цели тестирования](#4-цели-тестирования)
5. Виды тестирования (функциональные/нефункциональные/ по изменениям, по подходам)
6. Уровни тестирования. Пирамида тестирования
7. Отличие чек-листа от тест-кейса (правила написания)
8. Баг репорт
9. Методологии аджайл и скрам 
10. Виды требований 
11. Характеристик требований
12. Техники тест-дизайна (черный ящик)
13. Апи (Rest/SOAP)
14. Принципы REST
15. SQL (команды для выборки данных ), какие бывают БД И СУБД
16. Монолит / микросераис, двухзвенная и многозаенная архитектура
17. Мобилки: ANR , Жизненный цикл активности, разница в подходах в тестировании, прерывания , эмуляторы, симуляторы
18. Веб: инструмент девтулс, разница в походных в тестировании
19. Командные строки винды и линукс, основные команды, разница ОС
20. Десктоп: разница в тестировании десктоп прил

### [Автоматизированное тестирование](#автоматизированное-тестирование-1)

#### Основы Java
1. [Что такое Java?](#1-что-такое-java)
2. [Что такое JVM и JRE, JDK? В чём разница между ними?](#2-что-такое-jvm-и-jre-jdk-в-чём-разница-между-ними)
3. [Что такое класс и объект в Java? Приведите примеры.](#3-что-такое-класс-и-объект-в-java-приведите-примеры)
4. [Как создать класс в Java и как создать объект класса?](#4-как-создать-класс-в-java-и-как-создать-объект-класса)
5. [Какие типы переменных существуют в Java?](#5-какие-типы-переменных-существуют-в-java)
6. [Как выделяется память для разных типов переменных?](#6-как-выделяется-память-для-разных-типов-переменных)
7. [Модификаторы доступа к классам/ методам/ переменным](#7-модификаторы-доступа-к-классам-методам-переменным)
8. [Final, finally и finalize()](#8-final-finally-и-finalize)
9. [Что такое метод в Java? Как его создать?](#9-что-такое-метод-в-java-как-его-создать)
10. [Что такое массив в Java? Какие виды массивов бывают?](#10-что-такое-массив-в-java-какие-виды-массивов-бывают)
11. [Что такое цикл в Java? Назовите виды циклов](#11-что-такое-цикл-в-java-назовите-виды-циклов).
12. [Что такое оператор if-else в Java? Для чего он используется?](#12-что-такое-оператор-if-else-в-java-для-чего-он-используется)
13. [Что такое наследование в Java? Объясните на примере.](#13-что-такое-наследование-в-java-объясните-на-примере)
14. [Что такое полиморфизм в Java? Поясните на примере.](#14-что-такое-полиморфизм-в-java-поясните-на-примере)
15. [Статический и динамический полиморфизм](#15-статический-и-динамический-полиморфизм)
16. [Что такое инкапсуляция в Java? Приведите пример.](#16-что-такое-инкапсуляция-в-java-приведите-пример)
17. [Что такое Абстракция в Java? Приведите примеры ее реализации](#17-что-такое-абстракция-в-java-приведите-примеры-ее-реализации)
18. [Класс Object, какие методы есть?](#18-класс-object-какие-методы-есть)
19. [Методы equals и hashCode?](#19-методы-equals-и-hashcode)

#### Коллекции

20. [Что такое коллекции в Java?](#20-что-такое-коллекции-в-java)
2.  [Какие виды коллекций существуют в Java и чем они отличаются друг от друга?](#21-какие-виды-коллекций-существуют-в-java-и-чем-они-отличаются-друг-от-друга)
22. [Как создать коллекцию в Java? Приведите примеры.](#22-как-создать-коллекцию-в-java-приведите-примеры)
23. [В чём разница между списком (List), множеством (Set) и картой (Map)?](#23-в-чём-разница-между-списком-list-множеством-set-и-картой-map)
24. [Что такое ArrayList и LinkedList? В каких случаях следует использовать каждый из них?](#24-что-такое-arraylist-и-linkedlist-в-каких-случаях-следует-использовать-каждый-из-них)
25. [Что такое HashSet и TreeSet? В чём их отличие?](#25-что-такое-hashset-и-treeset-в-чём-их-отличие)
26. [Что такое HashMap и TreeMap? В чём их различие?](#26-что-такое-hashmap-и-treemap-в-чём-их-различие)
27. [Что такое итератор в Java и как его использовать?](#27-что-такое-итератор-в-java-и-как-его-использовать)
28. [Что такое сортировка в коллекциях и какие методы сортировки существуют?](#28-что-такое-сортировка-в-коллекциях-и-какие-методы-сортировки-существуют)

#### Компараторы

29. Что такое компаратор (comparator) в Java?
30. В чём разница между использованием метода compareTo и реализацией интерфейса Comparator?
31. Как реализовать интерфейс Comparator для сравнения объектов определённого класса?
32. Какие методы есть у интерфейса Comparator и как они используются?
33. Можно ли использовать один и тот же компаратор для разных классов?
34. Может ли компаратор быть статическим методом?
35. Может ли класс реализовать более одного компаратора?

#### Исключения

36. Что такое исключение (exception) в Java?
37. Какие виды исключений существуют в Java и чем они отличаются друг от друга?
38. Как создать собственное исключение в Java? Приведите примеры.
39. В чём разница между проверяемыми (checked) и непроверяемыми (unchecked) исключениями?
40. Как обработать исключение в коде? Приведите пример.
41. Что такое try-catch-finally блок и как он работает?
42. Может ли быть несколько блоков catch для одного try блока?
43. Можно ли использовать несколько исключений в одном блоке catch?
44. Что такое иерархия исключений и как она связана с обработкой исключений?

#### Дженерики 

45. Что такое дженерики (generics) в Java?
46. Какие преимущества дают дженерики при разработке программ?
47. Как создать класс с использованием дженериков? Приведите примеры.
48. В чём разница между сырыми типами (raw types) и обобщёнными типами (generic types)?
49. Что такое подстановочные типы (wildcards) и как они используются?
50. Может ли класс иметь несколько параметров типа?
51. Можно ли создавать массивы с использованием дженериков?
52. Могут ли дженерики использоваться с примитивными типами данных?
53. Что такое стирание типов (type erasure) и как оно влияет на использование дженериков во время выполнения программы?
54. Какие ограничения накладываются на использование обобщённых методов и классов?

#### Инструменты тестирования 

55. Сборщики проектов, какие знаете?
56. Maven - какие фазы
57. Gradle - какие таски
58. Как подключать зависимости в проект
59. Назовите основные библиотеки для тестирования на Java.
60. RestAssured, Selenium, JBDC
61. Библиотека Selenium - из каких компонентов стоит?
62. Как работать с webdriver
63. Как можно обращаться к элементам в Selenium
64. RestAssured - для чего предназначена, как настроить спецификации запросов и ответов?
65. Что такое Pojo?
66. Как сокращать код в использовании классов оболочек? (Lombok - его аннотации)
67. Какая констуркция используется для формирования запросов? (given - when - then)
68. Какая часть конструкции не обзятельна (then)
69. Библиотека для формирования отчетов Allure
70. Какие аннотации алюр вы знаете?
71. JBDC
72. Как формировать запросы в JBDC?
73. В чём разница между JUnit, TestNG и другими библиотеками для тестирования? (это фреймворки)
74. Как настроить и запустить тест с использованием JUnit или другой библиотеки?
75. Что такое аннотации @Test, @Before, @After и как они используются?
76. Параметризованные тесты как использовать? (@DataProvider)

## Ручное тестирование

### 1. QA QC Тестирование 

**Тестирование проводится после того, как продукт был создан или в случае статических испытаний после того, как документ был написан. Обеспечение качества подразумевает деятельность, которая обеспечивает качество продукта на всех этапах его создания.**

+ **Testing (тестирование)** - прохождение тест кейсов и локализация дефектов. Тестирование начинается на одноименном этапе тестирования, т.е. когда код написан и готов к тестированию. 
+ **QC** - контроль качества продукта - анализ результатов тестирования и качества “билдов”, в процессе разработки. QC включается в процесс, когда есть то, что можно проконтролировать. Например, на этапе анализа требований, составить матрицу трассировки (проверить все ли требования покрыты ТС). 
+ **QA** - решает глобальные задачи. Планирует и оптимизирует процессы, создает WF, анализирует работу тестировщиков и QC, решает возникающие проблемы и предотвращает их появление. Подключается до фактического старта работ.
Если говорить о QA специалисте, то его деятельность направлена на улучшение процесса разработки ПО, предотвращения дефектов и ошибок. Именно это приводит к повышению качества продукта.

#### Обязанности QA:

+ Настройка процессов работы на проекте
+ Разработка стратегий тестирования
+ Разработка тестовой документации и оптимизация тестов
+ Работа с рисками
+ Мероприятия по предотвращению дефектов
+ Построение и поддержка эффективных коммуникаций как с клиентом, так и с командой
+ Подбор и внедрение инструментов для тестирования и улучшения процессов 
+ Внедрение и сбор метрик на проекте
___

### 2. Что такое тестирование

`Тестирование` программного обеспечения – это процесс исследования ПО с целью получения информации о качестве продукта.

По сути тестирование представляет собой проверку соответствия между реальным и ожидаемым поведением программы, осуществляемую на конечном наборе тестов, выбранном определенным образом.

`Тестировщик` - это специалист, основная задача которого протестировать приложение и дать оценку его состояния в данный момент времени.

**Тестирование не обеспечивает качество само по себе.** Тестирование даёт оценку качеству. Тестирование может способствовать повышению качества системы программного обеспечения, если найденные дефекты исправлены прежде, чем система передана в эксплуатацию. 

Доскональное тестирование систем и документации может уменьшить риск возникновения проблем во время функционирования. Поэтому тестирование важно, особенно на ранних этапах.
___

### 3. Принципы тестирования

1. Тестирование демонстрирует наличие дефектов. но не может доказать, что их нет.
2. Исчерпывающее тестирование недостижимо. Вместо исчерпывающего тестирования должны использоваться анализ рисков и расстановка приоритетов, чтобы более точно сфокусировать усилия по тестированию.
3. Раннее тестирование - чтобы найти дефекты как можно раньше, активности по тестированию должны быть начаты как можно раньше.
4. Скопление дефектов - Усилия тестирования должны быть сосредоточены пропорционально ожидаемой, а позже реальной плотности дефектов по модулям. Как правило, большая часть дефектов, обнаруженных при тестировании или повлекших за собой основное количество сбоев системы, содержится в небольшом количестве модулей.
5. Парадокс пестицида - Если одни и те же тесты будут прогоняться много раз, в конечном счете этот набор тестовых сценариев больше не будет находить новых дефектов.
6. Тестирование зависит от контекста
7. Заблуждение об отсутствии ошибок. Обнаружение и исправление дефектов не помогут, если созданная система не подходит пользователю и не удовлетворяет его ожиданиям и потребностям.
___

### 4. Цели тестирования

+ повысить вероятность того, что приложение будет работать правильно при любых обстоятельствах и будет соответствовать всем описанным требованиям;
+ предотвратить появление дефектов; 
+ предоставить актуальную информацию о состоянии продукта для принятия управленческих решений.
___

### 6. Уровни тестирования. Пирамида тестирования

#### Уровни тестирования 

1. Компонентное тестирование (модульное). Это тестирование программы на уровне отдельно взятых модулей, функций или классов. **Цель компонентного тестирования**: выявление локализованных в модуле ошибок в реализации алгоритмов, а также определение степени готовности системы к переходу на следующий уровень разработки и тестирования. При компонентном тестировании проводятся unit-тесты.
2. Интеграционное тестирование - тесты, проверяющие корректность взаимодействия отдельных модулей друг с другом.
	+ Компонентный интеграционный уровень (Component Integration testing) проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
	+ Системный интеграционный уровень (System Integration Testing) – проверяется взаимодействие между разными системами после проведения системного тестирования.
	+ Снизу вверх - Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются.
	+ Сверху вниз - Вначале тестируются все высокоуровневые модули и постепенно один за другим добавляются низкоуровневые. 
	+ Большой взрыв - Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование.
3. Системное тестирование - проверка как функциональных, так и не функциональных требований в системе в целом.
	+ На базе требований
	+ На базе use case
4. Приемочное тестирование. Формальный процесс тестирования, который проверяет работоспособность системы, частей системы или отдельных нефункциональных характеристик системы согласно **плану приёмочных работ**.
	+ Пользовательское приемочное тестирование. (UAT). Тестирование, которое проводится конечными пользователями, чтобы убедиться, что продукт соответствует их потребностям и ожиданиям.
	+ Эксплуатационное (приемочное) тестирование. Приемочное тестирование, проводимое системными администраторами (тестирование резервного копирования\восстановления, восстановление после сбоев, управление пользователями и пр.)
	+ Контрактное и правовое приемочное тестирование. Контрактное приемочное тестирование выполняется для проверки требований, предъявляемых контрактом к разрабатываемому ПО.
	+ Альфа- и бета-тестирование. Эти виды тестирования проводятся на финальных этапах разработки, чтобы получить обратную связь от пользователей перед выпуском продукта. Альфа-тестирование выполняется организацией, разрабатывающей продукт, но не группой разработчиков. Бета-тестирование, или тестирование в условиях эксплуатации, выполняется покупателями или потенциальными заказчиками на их собственных мощностях

#### Пирамида тестирования

«Пирамида тестирования» (пирамида тестов) — абстракция, которая означает группировку тестов программного обеспечения по разным уровням детализации.

Из этой пирамиды главное запомнить два принципа: 
1. Писать тесты разной детализации. 
2. Чем выше уровень, тем меньше тестов. 

На нижнем уровне находятся модульные тесты. На среднем - интеграционные. На верхнем - E2E. Чем выше уровень, тем сложнее, дольше и дороже тесты.

Придерживайтесь формы пирамиды, чтобы придумать здоровый, быстрый и поддерживаемый набор тестов. Напишите много маленьких и быстрых юнит-тестов. Напишите несколько более общих тестов и совсем мало высокоуровневых сквозных тестов, которые проверяют приложение от начала до конца.

___

## Автоматизированное тестирование

### 1. Что такое Java?

**Java** - высокоуровневый (не нужно работать с памятью и процессами напрямую) язык программирования, построенный на основе парадигмы ООП (объектно-ориентированное программирование). 

#### Где используется

Чаще всего java используется для мобильной разработки (часто используют и kotlin вместо него), разработки десктопных, серверных приложений и микросервисов, в Enterprise разработке (сложных больших программ для удовлетворения бизнес-потребностей). Ну и для тестирования.

#### Платформы

При разработке необходимо выбрать пакет (платформу). В Java доступны следующие платформы: *Java Enterprise Edition* (Java EE) (для Enterprise), *Java Standard Edition* (Java SE) (для общего назначения) и *Java Mobile Edition* (Java ME) (для мобилок).
___
### 2. Что такое JVM и JRE, JDK? В чём разница между ними?

#### JVM

**JVM** (Java Virtual Machine) - платформа на которой запускаются java программы. Она управляет и оптимизирует память, используемую приложением. Также включает в себя сборщик мусора (очищает из памяти элементы, к которым нет доступа в программе), загрузчик классов (загружает классы в контекст). Также отвечает за распределение и поддержание ссылочной структуры. 
По сути JVM это платформа, с помощью которой обеспечивается кроссплатформенность программ на Java. Независимо от ОС и аппаратной платформы java-программы будут работать одинаково благодаря JVM.

#### JDK

**JDK** (Java Development Kit) представляет собой пакет инструментов для _разработки_ программного обеспечения. Это программный пакет, который вы загружаете для создания Java-приложений. Включает в себя компилятор и стандартные библиотеки классов.  

#### JRE
**JRE** (среда выполнения Java) представляет собой пакет инструментов для _запуска_ Java-кода. JRE может использоваться, как отдельный компонент для простого запуска Java-программ, либо быть частью JDK.  JRE содержит библиотеки классов, загрузчик классов и виртуальную машину Java. 
По сути JRE является контейнером для компонентов и отвечает за организацию их деятельности. Она берет Java-код, объединяет его с необходимыми библиотеками и запускает JVM для его выполнения. 
___

### 3. Что такое класс и объект в Java? Приведите примеры.

Java - объектно-ориентированный язык программирования. Это значит, что программы на Java построены вокруг классов и объектов. 

**Класс** — это шаблон для создания объектов, которые представляют собой некоторую сущность в рамках системы. Классы содержат состояние (данные) в виде полей и поведение в виде [методов](#9-что-такое-метод-в-java-как-его-создать).

**Объект** (экземпляр класса) - это конкретная реализация класса (то есть по сути шаблона), которая занимает память и имеет своё состояние (значения полей). 

Примеры: 
+ Класс автомобиль. Он будет содержать поля для хранения информации о марке, цвете и других характеристиках автомобиля, а также методы для взаимодействия с ним. Таким образом  создаётся шаблон для создания объектов, которые являются абстрактным представлением сущности автомобиля в программе. Сами экземпляры будут конкретными реализациями этого класса со своим состоянием. 
+ Класс человек. Будет содержать имя, пол, возраст и т.д. По аналогии с автомобилем представляет шаблон для реализации конкретных представлений сущности в программе.

___

### 4. Как создать класс в Java и как создать объект класса?

Для создания класса используется ключевое слово `Class`. Внутри фигурных скобок определяются поля и [методы](#9-что-такое-метод-в-java-как-его-создать) этого класса, в том числе и конструктор, который является методом для инициализации данных экземпляра класса. 

> Если мы не задаём конструктор, то неявно создаётся конструктор по умолчанию без параметров. Конструкторов может быть несколько и они могут вызывать друг друга.

<a id="no-getters-and-setters-1"></a>
Продолжая пример с автомобилем:

```Java
public class Car {
    // Поля 
    String brand; // марка автомобиля
    String color; // цвет
    int speed;    // текущая скорость

    // Конструктор (для создания объекта)
    public Car(String brand, String color) {
        this.brand = brand;
        this.color = color;
        this.speed = 0; // начальная скорость
    }

    // Методы (действия)
    public void accelerate(int increment) {
        speed += increment; // увеличиваем скорость
    }

    public void brake(int decrement) {
        speed -= decrement; // уменьшаем скорость
    }

    public void displayInfo() {
        System.out.println("Brand: " + brand + ", Color: " + color + ", Speed: " + speed + " km/h");
    }
}
```

Для создания объекта необходимо вызвать его конструктор с помощью оператора `new` (оператор `new` выделяет память под объект):
```java
public class Main {
    public static void main(String[] args) {
        // Создаём объект класса Car
        Car myCar = new Car("Toyota", "Red");
	}
}
```
___
### 5. Какие типы переменных существуют в Java?

Java - статически типизированный язык программирования. Это значит, что для каждой переменной тип жёстко фиксируется и задаётся один раз при объявлении. Поэтому тип нужно всегда указывать. (В питоне, например, можно написать a = 5, а потом a = "Привет". Тут так нельзя) 

> Ключевое слово var просто определяет тип данных по значению. Поэтому статическая типизация не нарушается.

#### Примитивы

В Java существует 8 примитивных типов данных:
1. `byte` - содержит целые числа (от -128 до 127). Занимает 1 байт в памяти. (Используется для оптимизации памяти, когда не нужно использовать большие числа)
2. `short` - содержит целые числа. Занимает 2 байта в памяти. (Используется для оптимизации памяти, когда не нужно использовать большие числа)
3. `int` - содержит целые числа. Занимает 4 байта в памяти. (Чаще всего используется для целых чисел)
4. `long` - содержит целые числа. Занимает 8 байт в памяти. (Используется, когда не хватает размеров `int`)
5. `float` - содержит числа с плавающей точкой (дробные числа). Занимает 4 байта в памяти. (Используется для оптимизации памяти, когда не нужно использовать большие числа или числа где много знаков после запятой)
6. `double` - содержит числа с плавающей точкой (дробные числа). Занимает 8 байт в памяти. (Чаще всего используется для чисел с плавающей точкой)
7. `char` -  содержит один строчный символ в кодировке UTF-16. Занимает 2 байта в памяти. (Задаётся печатным символом в одинарных кавычках или числом, соответствующим номеру символа в таблице кодировки)
8. `boolean` - содержит логическое значение *true* либо *false*. Занимает 1 байт в памяти.

Все остальные типы, в том числе `String` - являются ссылочными.


> Для примитивов есть специальные классы-оболочки Integet, Float, Double и т.д. С помщью которых примитив можно создать как ссылочный объект. Например, это нужно в дженериках, т.к. они работают только с ссылочными типами.

#### Преобразования примитивных типов

Примитивные типы без потери данных можно преобразовывать только если это расширяющее преобразования. То есть тип которому нужно меньше памяти преобразуется в тип которому нужно больше памяти. (Маленький горшок можно положить в большой, а вот в большой в маленький не залезет, хотя есть и другая интерпретация... Осёл из Шрека может создать дракосликов, а вот если были бы дракон и ослица...).

Расширяющее преобразование называется неявным и происходит автоматически без потери точности:
```java
byte a = 0;
int b = a; // 0
```

В обратном случае используется явное преобразования с указанием типа:
```java
int a = 128;
byte b = (byte)a; // 0
```

При этом если данные "не помещаются" в переменную, то происходит потеря данных (старшие биты в двоичном представлении обрезаются).

___

### 6. Как выделяется память для разных типов переменных?

Отличие ссылочных типов от примитивов в том, что примитивы хранят своё значение в области памяти, называемой *стеком*. А ссылочные типы хранят свои значения в области памяти называемой *кучей* (heap). В стеке лишь создаётся ссылка на расположение этих значений в куче. Поэтому мы можем присвоить разным переменным (ссылкам на объект) одни и те же данные из памяти. Это происходит в том числе когда мы передаём объекты в методы (приравниваем локальной переменной метода ссылку на данные в куче). Поэтому есть такие приколы:

<a id="no-getters-and-setters-2"></a>
```java
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Toyota", "Red"); // получили ссылку на // данные в куче
        Car myCar2 = myCar; // ссылается на те же данные
        myCar2.color = "Blue"; // изменили сами данные
        System.out.println(myCar.color); // Blue
	}
}
```


> Со строками отдельная тема. Они хранятся в куче в специальной области String pool. Если не вдваваться в подробности, то там возможны свои приколы. Поэтому, например, строки всегда нужно сравнивать через equals  


___
### 7. Модификаторы доступа к классам/ методам/ переменным

В Java есть 4 **модификатора доступа**:
+ `public` - доступ к элементам в любом месте программы. В других классах, пакетах и т.д.
+ `private` - доступ к элементам только внутри данного класса.
+ `protected` - доступ к элементам в самом классе, в пакете и в [цепочке наследования](#13-что-такое-наследование-в-java-объясните-на-примере).
+ `default` - когда не указывается никакого ключевого слова. Доступ к элементам в рамках пакета. (отличается от `protected` тем, что если класс-наследник будет в другом пакете, то он доступ к элементу не получит)

Модификаторы доступа обеспечивают принцип ООП - [инкапсуляцию](#16-что-такое-инкапсуляция-в-java-приведите-пример). 

___
### 8. Final, finally и finalize()

#### final

`final` - ключевое слово, у которого несколько назначений:
+ Задаёт константу. При этом значение переменной  должно задаваться сразу (или в конструкторе если это поле класса) и не может изменяться:
```java
final int a = 5;
a = 4; // ошибка
final int b; // тоже ошибка, нужно указать значение
```
+ Запрещает [наследование классов](#13-что-такое-наследование-в-java-объясните-на-примере). Ставится перед ключевым словом `class`
+ Запрещает [переопределение методов](#динамический-полиморфизм). Ставится в объявлении метода.

#### finally
**`finally`** используется в конструкции [try-catch-finally](#41-что-такое-try-catch-finally-блок-и-как-он-работает) для выполнения кода, который должен быть выполнен вне зависимости от того, произошло исключение или нет (и даже после `return`). Блок `finally` гарантирует, что определённый код будет выполнен не зависимо от того, произошло ли исключение и было ли оно обработано. Важно использовать когда, например, нужно закрыть какие-то потоки или просто нужно залоггировать и т.п.

#### finalize()
Метод **`finalize()`** в Java — это метод класса [Object](#18-класс-object-какие-методы-есть), который может быть переопределён. Он вызывается перед тем, как объект будет удалён сборщиком мусора (когда объект в куче лежит, а ссылки в стеке на него нет). Однако его использование не рекомендуется, так как он имеет ряд серьёзных недостатков и не гарантирует своевременного выполнения.

___
### 9. Что такое метод в Java? Как его создать?

**Метод** в Java — это именованный блок кода, который выполняет определённую задачу. Методы используются для организации кода программы и для повторного использования кода. Они могут принимать входные параметры и возвращать значение (но это необязательно).

Создание метода:
<модификатор доступа> <тип\_возвращаемого\_значения> <имя\_метода>(<параметры>) { 
	// Тело метода 
}

Примеры:
```java
public static void sayHello() { 
	System.out.println("Привет, мир!"); 
}

public static int sum(int a, int b) {
	return a + b; 
}
```

Вызов:
```java
sayHello();
int sum = sum(2, 3);
```
Оператор `return` возвращает значение указанного типа из метода. Если тип `void` то оператор просто выходит из метода.

#### Методы с переменным числом параметров
В Java можно создавать методы с переменным числом параметров:

```java
static void sum(int ...nums){
    int result = 0;
    for(int n: nums)
		result += n;
	    System.out.println(result);
    }
}

sum(2, 3, 5, 7); // 7
sum(2, 2); // 4
```

Все передаваемые данные засовываются в [массив](#10-что-такое-массив-в-java-какие-виды-массивов-бывают). 

`static` обозначает, что метод вызывается на уровне класса, а не конкретного объекта. То есть не нужно создавать объект, чтобы использовать метод. Статический метод вызывается по имени класса и не может получить доступ к нестатическим полям объекта (логично, он не знает о каком конкретно объекте идёт речь). Пример вызова статического метода: `Math.max()`;

___ 
### 10. Что такое массив в Java? Какие виды массивов бывают?

**Массив** в Java — это структура данных, которая позволяет хранить набор значений одного типа. Массивы в Java имеют фиксированный размер, который задаётся при создании. Массивы не имеют встроенных методов добавления/удаления элементов.

Примеры создания массивов:
```java
int[] array = new int[4]; // одномерный
int arr[] = {1, 2, 3, 4}; // одномерный
int[][] matrix = new int[3][3]; // двумерный
int[][] mat = {{1, 2, 3}; {4, 5, 6}; {7, 8, 9}}; // двумерный
int[][] zub = new int[2][]; // зубчатый
```

Доступ к элементам массива осуществляется с помощью индекса, начиная с 0. Например, `arr[0]`. Для получения количества элементов в массиве используется поле `length`. Например, `arr.length`;

> После объявления массива, если мы явно не задаём значения в нём с помощью {}, то в нём хранятся дефолтные значения для типа данных элементов массива. Для целочисленных типов это 0, для чисел с плавающей точкой 0.0, для char - нулевой символ, для boolean - false, а для ссылочных типов - null


#### Виды массивов
+ Одномерные массивы - набор элементов одного типа, выстроенных в ряд.
+ Многомерные массивы - массивы, содержащие несколько других массивов (или массивов массивов) одинаковой длинны. Как правило используются двумерные массивы. 
+ Зубчатые (нерегулярные, рваные) массивы - массив, в котором каждый элемент является массивом. При этом внутренние массивы могут иметь разную длину. 

___
### 11. Что такое цикл в Java? Назовите виды циклов.

**Цикл** в Java — это конструкция, которая позволяет многократно выполнять блок кода, пока выполняется определённое условие.

#### Виды циклов
+ `while` - используется, когда количество итераций (запусков тела цикла) заранее неизвестно, но зависит от выполнения условия. 
```java
int i = 0; 
while (i < 5) { 
	System.out.println("Итерация: " + i); 
	i++; 
}

// Часто можно встретить такую штуку:
while(true) { // бесконечный цикл
	i++;
	if(i > 100) {
		break; // выход из цикла 
	}
}
```
+ `do-while` - Используется, когда тело цикла должно быть выполнено *хотя бы один раз*, независимо от условия.
```java
int i = 0; 
do { 
	System.out.println("Итерация: " + i); 
	i++; 
} while (i > 5); // цикл запустится 1 раз
```
+ `for` - Используется, когда заранее известно количество итераций.
```java
for (int i = 0; i < 5; i++) { 
	System.out.println("Итерация: " + i); 
}

int i = 10;
for(;i<20;) { // каждый из составляющих цикла можно пропустить
	i++;
}
```
+ `for-each` - Применяется для перебора элементов [массивов](#10-что-такое-массив-в-java-какие-виды-массивов-бывают) или [коллекций](#20-что-такое-коллекции-в-java).
```java
int[] numbers = {1, 2, 3, 4, 5}; 
for (int num : numbers) { 
	System.out.println("Элемент: " + num); 
}
```

#### break и continue

`break` и `continue` - ключевые слова для управления ходом управления цикла.
+ `break` — завершает выполнение цикла, не выполняя до конца всё тело цикла.
+ `continue` — пропускает текущую итерацию и переходит к следующей, не выполняя до конца всё тело цикла.

___
### 12. Что такое оператор if-else в Java? Для чего он используется?

**Оператор `if-else`** в Java — это конструкция, которая позволяет выполнять разные блоки кода в зависимости от выполнения заданного условия.

Пример:
```java
if (age < 18 && age > 0) { 
	System.out.println("Доступ запрещён."); 
} else if(age < 100) { // если предыдущее условие не выполнилось 
	System.out.println("Доступ разрешён."); 
} else { //  если все предыдущие условия не выполнились
	System.out.println("Ошибка. Неправильный возраст"); 
}
```

Блоки `else-if` и `else` необязательные. Также можно вкладывать `if-else` друг в друга:
```java
if (number > 0) { 
	if (number % 2 == 0) { 
		System.out.println("Положительное чётное число."); 
	} else { 
		System.out.println("Положительное нечётное число."); 
	}
} else { 
	System.out.println("Число не положительное."); 
}
```

#### Тернарный оператор

Для простых проверок можно использовать тернарный оператор `? :`

```java
String access = (age >= 18) ? "Доступ разрешён" : "Доступ запрещён";
```

Если условие в скобках выполняется то возвращается значение после `?`, иначе - значение после `:`. То есть аналогично:
```java
String access;
if(age >= 18) {
	access = "Доступ разрешён";
} else {
	access = "Доступ запрещён";
}
```

___

### 13. Что такое наследование в Java? Объясните на примере.

**Наследование** — это один из принципов (парадигм) объектно-ориентированного программирования. Он позволяет создавать новый класс (называемый *производным*, *дочерним* или *подклассом*) на основе уже существующего класса (называемого _базовым_, _родительским_ или _суперклассом_).

Подкласс наследует поля (переменные) и методы родительского класса, а также может добавлять свои собственные или переопределять унаследованные методы.

Класс может наследоваться только от одного класса.

Пример.
Автомобиль является транспортом. Он обладает свойствами транспорта (марка, цвет, скорость и т.д.) и обладает таким же поведением (он может поехать куда-то, остановиться и т.п.). Однако у него может быть свои собственные уникальные свойства (количество дверей, тип двигателя и т.д.) и своё собственное поведение (прогреть движок, включить кондиционер и т.п.). В таком случае автомобиль как экземпляр класса *Car* будет наследовать данные и поведение класса *Vehicle*. Потому что сущность автомобиля - более расширенное, дополненное представление сущности транспорта.

<a id="no-getters-and-setters-3"></a>
Реализация наследования:

```java
class Vehicle { 
	String brand; 
	int speed;
	 
	public Vehicle(String brand, int speed) { 
		this.brand = brand; 
		this.speed = speed; 
	} 
	
	public void displayInfo() { 
		System.out.println("Марка: " + brand);
		System.out.println("Скорость: " + speed + " км/ч"); 
	} 
}

class Car extends Vehicle { 
	int doors; 
	
	public Car(String brand, int speed, int doors) { 
		super(brand, speed); // Вызов конструктора базового класса
		this.doors = doors; 
	} 
}

public class Main { 
	public static void main(String[] args) { 
		// Создаём объект автомобиля 
		Car car = new Car("Toyota", 180, 4); 
		car.brand; // Наследуется от класса Vehicle
		car.speed; // Наследуется от класса Vehicle
		car.doorsl // Определено в классе Car
		car.displayInfo(); // Переопределено в классе Car
	}
}
```

Для того чтобы наследовать класс необходимо использовать ключевое слово `extends` в его объявлении. 
С помощью ключевого слова `super` можно обращаться к элементам родительского класса. В примере вызывается конструктор базового класса. При этом вызов конструктора базового класса должен идти в самом начале в конструкторе производного класса.

___

### 14. Что такое полиморфизм в Java? Поясните на примере.

**Полиморфизм** — это один из принципов (парадигм) объектно-ориентированного программирования. Он заключается в способности одного и того же метода или объекта работать по-разному в зависимости от того, с каким типом данных он используется. Это делает код более гибким, расширяемым и удобным для работы с иерархиями классов.

В качестве примера полиморфизма можно привести [переопределение метода](#динамический-полиморфизм). Переопределяя метод, мы изменяем его поведение в классе-потомке. Таким образом один и тот же метод ведёт себя по-разному в зависимости от того, объект какого класса его вызывает.
___
### 15. Статический и динамический полиморфизм

#### Статический полиморфизм

Статический (ad-hoc) полиморфизм определяется на этапе компиляции. К статическому полиморфизму относится **перегрузка методов**. 

**Перегрузка методов** (method overloading) в Java — это возможность создавать в одном классе несколько методов с одним и тем же именем, но с разными наборами параметров (типами, количеством, порядком), т.е. с разными сигнатурами методов.

Пример:
```java
public int add(int a, int b) { 
	return a + b; 
} 

public int add(int a, int b, int c) { 
	return a + b + c;
}
```

Java определяет, какой именно метод вызвать, на основе списка параметров (их типа, количества и порядка). Возвращаемый тип не участвует в сигнатуре метода.

Также к статическому полиморфизму относятся [шаблоны функций](#45-что-такое-дженерики-generics-в-java). (вроде как, перед собесом нужно чекнуть, или не упоминать)
#### Динамический полиморфизм

Динамический (параметрический) полиморфизм определяется на этапе выполнения программы (в рантайме). К динамическому полиморфизму относится переопределение методов. 

**Переопределение методов** (Method Overriding) — это механизм, позволяющий подклассу предоставить свою реализацию метода, который уже определён в его родительском классе. Метод в подклассе должен иметь ту же сигнатуру, такой же или менее строгий модификатор доступа, тот же возвращаемый тип, как и у метода из родительского класса.

Также переопределяемый метод в классе-потомке помечается аннотацией \@Override. (Фактически, это необязательно, но так принято)

Пример:
```java
class Animal {
    // Метод в родительском классе
    public void sound() {
        System.out.println("Животное издаёт звук.");
    }
}

class Dog extends Animal {
    // Переопределение метода sound()
    @Override
    public void sound() {
        System.out.println("Собака лает: Гав-гав!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog(); // Ссылка на Animal, но объект Dog

        myAnimal.sound(); // Животное издаёт звук.
        myDog.sound(); // Собака лает: Гав-гав!
    }
}
```


> Переопределяемые методы из родительского класса часто называют виртуальными
___

### 16. Что такое инкапсуляция в Java? Приведите пример.

**Инкапсуляция** — это один из принципов (парадигм) ООП, который заключается в объединении данных и методов, а также сокрытии деталей реализации и предоставлении доступа к данным только через определенные методы. Такое сокрытие также называют принципом чёрного ящика: мы запрашиваем какое-то поведение или информацию из класса и получаем результат, не взаимодействуя с конкретной реализацией поведения в классе.

> Аналогия из реальной жизни (чисто для понимания теории): для того, чтобы заварить кофе с помощью автоматической кофемашины, необходимо взаимодействовать с её интерфейсом (выбрать режим, нажать кнопки и т.п.). При этом нам не нужно разбирать кофемашину и запускать её отдельные компоненты или что-то в ней шаманить. Это и есть принцип чёрного ящика - мы не знаем что происходит внутри кофемашины, поэтому она для нас как чёрный ящик.

В Java инкапсуляция реализуется с помощью [модификаторов доступа](#7-модификаторы-доступа-к-классам-методам-переменным), *геттеров* и *сеттеров*. Мы должны правильно прописывать модификаторы доступа, чтобы у нас был доступ только к тому, что нам нужно для взаимодействия с объектом класса и не более.

#### Геттеры и сеттеры

**Геттеры** и **сеттеры** — это методы, которые позволяют получать и изменять значения приватных полей класса. 

Пример:
```java
class Person {
    private String name;
    private int age;

    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        setAge(age); // Используем сеттер с проверкой
    }

    // Геттер для имени
    public String getName() {
        return name;
    }

    // Сеттер для имени
    public void setName(String name) {
        this.name = name;
    }

    // Геттер для возраста
    public int getAge() {
        return age;
    }

    // Сеттер для возраста с валидацией
    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        } else {
            System.out.println("Ошибка: возраст должен быть положительным!");
        }
    }
```

Использование геттеров и сеттеров, помимо обеспечения инкапсуляции, добавляет гибкости к программе, ведь мы можем добавлять дополнительный функционал в эти методы (валидацию, как в примере, логгирование и прочее). Помимо этого, мы можем создать отдельно только геттеры, сделав поле *read only* (доступным только для чтения). (насчёт создания только сеттеров, сложно придумать случай когда такое понадобится)

Ранее в примерах ([тут](#no-getters-and-setters-1), [тут](#no-getters-and-setters-2) и [тут](#no-getters-and-setters-3)) я не добавлял геттеры и сеттеры для лаконичности кода, но вообще их принято создавать *всегда*.
___

### 17. Что такое Абстракция в Java? Приведите примеры ее реализации

**Абстракция** — это один из принципов (парадигм) объектно-ориентированного программирования (ООП). Он заключается в отделении концепции от конкретной реализации. Другими словами, для сущностей в программе выделяются общие значимые параметры, а конкретная реализация игнорируется. 

Абстракция в Java достигается с помощью *абстрактных классов* и *интерфейсов*.

#### Абстрактные классы

**Абстрактный класс** — это класс, экземпляр которого нельзя создать напрямую (через `new`). Он используется в цепочке наследования, для того чтобы задавать общие поля и методы для подклассов. 

В абстрактном классе могут содержаться абстрактные методы. Их особенность в том, что для них не нужно прописывать реализацию (тело метода). При этом, наследуемый класс обязан переопределить все абстрактные методы.  Если класс имеет хотя бы один абстрактный метод, то данный класс должен быть определен как абстрактный.  

Пример:
```java
// Абстрактный класс
abstract class Animal {
    protected String name;

    // Конструктор
    public Animal(String name) {
        this.name = name;
    }

    // Абстрактный метод (без реализации)
    abstract void makeSound();

    // Обычный метод (с реализацией)
    public void sleep() {
        System.out.println(name + " спит.");
    }
}

// Конкретный класс, реализующий абстрактные методы
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    // Реализация абстрактного метода
    @Override
    void makeSound() {
        System.out.println(name + " лает: Гав-гав!");
    }
}

// Использование абстракции
public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog("Бобик");
        dog.makeSound(); // Бобик лает: Гав-гав!
        dog.sleep(); // Бобик спит.
    }
}
```


#### Интерфейсы

**Интерфейс** — это абстрактный тип, который предоставляет спецификацию методов, которые должны быть в классе, реализующем этот интерфейс. Экземпляр интерфейса также нельзя создать напрямую. 

Все элементы интерфейса по умолчанию считаются `public` (поэтому модификаторы можно не прописывать). Интерфейсы содержат методы (статические с реализацией и не статические без реализации) и не содержат конструктора и полей. Если в интерфейсе всё-таки определить поле, то оно будет создано как публичная статическая константа. 

Чтобы реализовать интерфейс в объявлении класса необходимо прописать название этого интерфейса после ключевого слова `implements`. Классы могут реализовывать несколько интерфейсов (в отличие от наследования классов), и при этом обязаны переопределять методы из этих интерфейсов (абстрактные классы в сущности не обязаны). Однако, в интерфейсах существует возможность задавать реализацию нестатических методов по умолчанию с помощью ключевого слова `default`. Они могут быть не реализованы в классе, тогда будет вызвана реализация по умолчанию.

Пример:
```java
// Интерфейс
interface Vehicle {
	// Статическая константа
	String TYPE = "Транспорт";

    // Абстрактный метод
    void start();

    // Метод по умолчанию (Java 8+)
    default void stop() {
        System.out.println("Транспорт остановился");
    }

	// Статический метод
	static void honk() {
		System.out.println("Сигнал!");
	}
}

// Класс, реализующий интерфейс
class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Машина завелась");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start(); // Машина завелась
        car.stop();  // Транспорт остановился
        Vehicle.honk(); // Сигнал!
        Sistem.out.println(Vehicle.TYPE); // Транспорт
    }
}
```


Интерфейсы можно наследовать друг от друга с помощью ключевого слова `extends`. В таком случае класс, реализующий интерфейс, должен реализовать методы и из дочернего и из родительского интерфейсов:

```java
// Базовый интерфейс
interface Animal {
    void eat();
}

// Интерфейс, наследующий другой интерфейс
interface Pet extends Animal {
    void play();
}

// Класс, реализующий интерфейс Pet (и автоматически Animal)
class Dog implements Pet {
    @Override
    public void eat() {
        System.out.println("Собака ест корм.");
    }

    @Override
    public void play() {
        System.out.println("Собака играет с мячом.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Собака ест корм.
        dog.play(); // Собака играет с мячом.
    }
}
```
___

### 18. Класс Object, какие методы есть?

`Object` — это главный родительский класс всех классов в Java. Любой класс  по умолчанию наследуется от `Object`.

Класс `Object` содержит несколько полезных методов, которые могут быть переопределены в пользовательских классах.
+ `equals(Object obj)` - позволяет сравнить два объекта на равенство. (по умолчанию сравнивает указывают ли ссылки на один и тот же объект в памяти, т.е. через \==)
+ `hashCode()` - возвращает уникальный номер (хеш-код) объекта на основе его элементов.
+ `toString()` - возвращает строковое представление объекта. Вызывается автоматически в случаях когда объект нужно представить в виде строки, например, при выводе на консоль
```java
class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }

    // Переопределяем метод toString()
    @Override
    public String toString() {
        return "Person{name='" + name + "'}";
    }
}
```
+ `clone()` - cоздает копию объекта
+ `finalize()` - вызывается перед удалением объекта сборщиком мусора.
+ `wait()`, `notify()`, `notifyAll()` - методы для работы с многопоточностью. Нельзя переопределить

___

### 19. Методы equals и hashCode?

Методы `equals()` и `hashCode()` определены в классе `Object` и как правило переопределяются в пользовательских классах.

#### equals

Используется для сравнения объектов.  
По умолчанию сравнивает ссылки (т.е. `==`), но его можно переопределить для сравнения по содержимому.

Как правило имеет примерно такую реализацию:

```java
class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // если это тот же объект 
        if (!(obj instanceof Person)) return false; // проверка на принадлежность классу
        Person person = (Person) obj; // приведение к тому классу
        return name.equals(obj.name); // проверка совпадения данных 
    }
}
```

#### hashcode

Возвращает целочисленный хеш-код объекта, который используется в [коллекциях](#20-что-такое-коллекции-в-java).

Если `equals()` переопределен, обязательно необходимо переопределять `hashCode()`, чтобы равные объекты имели одинаковый хеш.


___
### 20. Что такое коллекции в Java?

Коллекции — структуры данных для хранения и управления группами объектов. Они представлены в виде набора классов и интерфейсов. Они входят в стандартную библиотеку Java и находятся в пакете `java.util`. 

Иерархия интерфейсов коллекций:

![[Pasted image 20241211020003.png]]

Collection: базовый интерфейс для всех коллекций и других интерфейсов коллекций
- Queue: очередь
- Deque: двусторонняя очередь
- List: списки
- Set: множества
- SortedSet: сортированные множества
- NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию
- Map: словарь. не наследуется от интерфейса Collection.

Эти интерфейсы частично реализуются абстрактными классами:
+ AbstractCollection - все коллекции
+ AbstractSet - множества
+ AbstractQueue - очереди
+ AbstractList - списки
+ AbstractSequentialList - связные списки
+ AbstractMap - словари

#### Методы интерфейса Collections

> Эти методы и методы в последующих вопросах привожу для справки. Очевидно, что их не нужно заучивать. Просто иметь представление о действиях, доступных с коллекциями. Хотя, всё же парочку основных методов (получение элементов, добавление, удаление, проверка на пустоту и т.п.) хорошо бы запомнить.

+ `boolean add(T item)`: добавление. При удачном добавлении возвращает `true`, при неудачном - `false`
+ `boolean addAll(Collection<V extends T> col)`: добавляет в коллекцию все элементы из коллекции `col`. При удачном добавлении возвращает `true`, при неудачном - `false`
+ `void clear()`: удаляет все элементы из коллекции
+ `boolean contains(Object item)`: возвращает `true`, если объект `item` содержится в коллекции, иначе возвращает `false`
+ `boolean containsAll(Collection c)` – возвращает true, если коллекция содержит все элементы из `c`
+ `boolean isEmpty()`: возвращает `true`, если коллекция пуста, иначе возвращает `false`    
+ `Iterator<E> iterator()`: возвращает объект [`Iterator`](#27-что-такое-итератор-в-java-и-как-его-использовать). Из интерфейса `Iterable`    
+ `boolean remove(Object item)`: возвращает `true`, если объект `item` удачно удален из коллекции, иначе возвращается false
+ `boolean removeAll(Collection<?> col)`: удаляет все объекты коллекции `col` из текущей коллекции. Если текущая коллекция изменилась, возвращает `true`, иначе возвращается `false`
+ `boolean retainAll(Collection<?> col)`: удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false
+ `int size()`: возвращает число элементов в коллекции
+ `Object[] toArray()`: возвращает массив, содержащий все элементы коллекции.

___

### 21. Какие виды коллекций существуют в Java и чем они отличаются друг от друга?

Виды коллекций:
+ Списки (List) - упорядоченные коллекции. Элементы в списке доступны по индексу. Реализации: `ArrayList` (динамический массив), `LinkedList` (связный список) 
+ Множества (Set) - неупорядоченный (может быть упорядоченным в конкретной реализации) набор элементов. Не позволяет хранить дублирующиеся элементы Реализации: `HashSet` (множество на основе хэш-таблицы), `LinkedHashSet` (пролинкованное множество на основе хэш-таблицы), `TreeSet` (множество на основе дерева) 
+ Очереди (Queue) - упорядоченные коллекции. Позволяют добавлять или удалять элементы только с начала или с конца коллекции. Реализации: `LinkedList` (связный список), PriorityQueue` (очередь приоритетов), `ArrayDeque` (двусторонняя очередь) 
+ Словари (Map) - ассоциативные массивы. Т.е. коллекции, хранящие данные в виде пар ключ-значение. Реализации: `HashSet` (словарь на основе хэш-таблицы), `LinkedHashSet` (пролинкованный словарь на основе хэш-таблицы), `TreeMap` (словарь на основе дерева)

___

### 22. Как создать коллекцию в Java? Приведите примеры.

Для того чтобы создать коллекцию в Java необходимо вызвать конструктор класса, реализующего коллекцию. Как правило доступны несколько конструкторов:
+ Без параметров - создаёт пустую коллекцию.
+ С числовым параметром - задаёт количество ячеек, которые будут зарезервированы в памяти под коллекцию (capacity). (не для всех коллекций)
+ С параметром типа `Collection` - создаёт коллекцию с элементами из другой коллекции.
+ С объектом [компаратора](). Для сортированных коллекций. 

Примеры:
```java
List<String> list = new ArrayList<>(); // пустой спиок
Set<String> set = new HashSet<>(list); // множество c элементами из 
// списка
Map<String, Integer> map = new HashMap<>(); // пустой словарь
ArrayDeque<String> deque = new ArrayDeque<>(3); // двойная очередь
// с 3 зарезервированными ячейками
```

Начиная с Java 9, можно создавать неизменяемые коллекции с помощью методов `List.of()`, `Set.of()`, `Map.of()`.

```java
    List<String> list = List.of("Apple", "Banana", "Cherry");
    Set<String> set = Set.of("Apple", "Banana", "Cherry");
    Map<String, Integer> map = Map.of("Apple", 10, "Banana", 5, "Cherry", 15);
```

___
### 23. В чём разница между списком (List), множеством (Set) и картой (Map)?

| Характеристика     | List                  | Set                             | Map                                         |
| ------------------ | --------------------- | ------------------------------- | ------------------------------------------- |
| Дубликаты          | Разрешены             | Запрещены                       | Ключи уникальны, значения могут повторяться |
| Порядок элементов  | В порядке добавления  | Зависит от реализации.          | Зависит от реализации                       |
| Доступ к элементам | По индексу            | Через [итератор](#27-что-такое-итератор-в-java-и-как-его-использовать)                | По ключу                                    |
| Реализации         | ArrayList, LinkedList | HashSet, LinkedHashSet, TreeSet | HashMap, LinkedHashMap, TreeMap             |
___
### 24. Что такое ArrayList и LinkedList? В каких случаях следует использовать каждый из них?  

`ArrayList` и `LinkedList` - классы, реализующие интерфейс `List`. Они используются для хранения упорядоченных коллекций элементов, но имеют разные внутренние структуры.

Методы интерфейса List:
- `void add(int index, E obj)`: добавляет в список по индексу `index` объект `obj`
- `boolean addAll(int index, Collection<? extends E> col)` - добавляет все элементы коллекции `col` на позицию `index`
- `E get(int index)`: возвращает элемент по индексу
- `int indexOf(Object obj)`: возвращает индекс первого вхождения объекта `obj` в список. Если объект не найден, то возвращается -1
- `int lastIndexOf(Object obj)`: возвращает индекс последнего вхождения объекта `obj` в список. Если объект не найден, то возвращается -1
- `ListIterator <E> listIterator ()`: возвращает объект [`ListIterator`](#27-что-такое-итератор-в-java-и-как-его-использовать) для обхода элементов списка
- `static <E> List<E> of(элементы)`: создает из набора элементов объект `List`
- `E remove(int index)`: удаляет объект из списка по индексу `index`, возвращая при этом удаленный объект
- `E set(int index, E obj)`: присваивает значение объекта `obj` элементу, который находится по индексу index
- `void sort(Comparator<? super E> comp)`: сортирует список с помощью [компаратора] `comp`
- `List<E> subList(int start, int end)`: получает набор элементов, которые находятся в списке между индексами start и end
#### ArrayList

ArrayList – содержит в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов. При создании можно указать параметр `capacity` - количество ячеек памяти, которые будут выделены при создании списка. После того как память будет заполнена, автоматически выделится дополнительные ячейки для добавления новых элементов. 

Конструкторы:
+ `ArrayList<T>()` - пустой список.
+ `ArrayList<T>(Collection<? extends T> col)` - список с элементами из коллекции `col`
+ `ArrayList<T>(int capacity)` - создаёт элемент с параметром `capacity`

#### LinkedList 

`LinkedList` основан на **двусвязном списке**. Каждый элемент (узел) помимо данных содержит ссылки на предыдущий и следующий элементы. Класс `LinkedList` реализует интерфейсы `List`, `Queue`, `Deque`. Некоторые методов оттуда:

- addFirst() / offerFirst(): добавляет элемент в начало списка
- addLast() / offerLast(): добавляет элемент в конец списка  
- removeFirst() / pollFirst(): удаляет первый элемент из начала списка
- removeLast() / pollLast(): удаляет последний элемент из конца списка
- getFirst() / peekFirst(): получает первый элемент
- getLast() / peekLast(): получает последний элемент

Конструкторы:
+ `LinkedList<T>()` - пустой список.
+ `LinkedList<T>(Collection<? extends T> col)` - список с элементами из коллекции `col`

#### Сравнение

`ArrayList` - это список на основе массива. `LinkedList` - связанный список на основе элементов и связи между ними.

В `ArrayList` доступ к элементу осуществляется по индексу. Тогда как в `LinkedList` доступ к элементу осуществляется перебором с начала/с конца списка (откуда ближе). Таким образом обращаться к элементу быстрее в случае `ArrayList`.

Добавление/удаление элементов в конец списка `ArrayList` осуществляется за константное время (не зависящее от размера списка). Но для элементов не в коне списка понадобится больше времени, потому что нужно сдвинуть все последующие элементы. В `LinkedList` добавление/удаление элементов в любом месте списка выполняются за константное время (не зависящее от размера списка). Таким образом вставлять/удалять элементы в произвольной позиции списка быстрее в случае `LinkedList`.

`LinkedList` выделяет дополнительную память для хранения ссылок на предыдущий и следующий элементы, поэтому он занимает больше памяти.

Элементы `ArrayList` располагаются в памяти последовательно, в одной непрерывной области. Элементы `LinkedList` могут располагаются в разных участках памяти. 

Чаще всего используется именно `ArrayList`, но в случаях, когда часто используется вставка/удаление в начале или середине списка, возможно, стоит выбрать именно `LinkedList`.

___

### 25. Что такое HashSet и TreeSet? В чём их отличие?

`HashSet`, `LinkedHashSet` и `TreeSet` — это три основные реализации интерфейса `Set` в Java. Все они используются для хранения уникальных элементов, но отличаются внутренней структурой, порядком хранения элементов и производительностью.

Сам по себе интерфейс Set содержит только методы интерфейса Collection, но при этом на них накладывается исключение, что в такой коллекции не может быть повторяющихся элементов.

#### HashSet и LinkedHashSet

`HashSet` - множество, на основе хеш-таблицы. Порядок элементов в таком множестве не гарантируется. При этом является самой эффективной реализацией множества (по времени и памяти).

Конструкторы:
- `HashSet()`: создает пустое множество
- `HashSet(Collection<? extends E> col)`: создает множество с элементами из коллекции col
- `HashSet(int capacity)`: параметр capacity указывает начальную емкость множества, которая по умолчанию равна 16.
- `HashSet(int capacity, float koef)`: параметр koef или коэффициент заполнения, значение которого должно быть в пределах от 0.0 до 1.0, указывает, насколько должна быть заполнена емкость объектами прежде чем произойдет ее расширение. Например, коэффициент 0.75 указывает, что при заполнении емкости на 3/4 произойдет ее расширение.

Так как `HashSet` основан на хеш-таблице, то добавление, получение и удаление элемента множества в среднем происходит за константное время (не зависящее от размера множества, то есть без перебора элементов). При этом, для классов, которые являются элементами множества необходимо переопределить методы `equals()` и `hashcode()`. Это нужно, чтобы можно было однозначно определить когда элементы равны, чтобы избежать дубликатов. 

> Схема такая: при добавлении элемента, сначала ищется элемент с таким же хеш-кодом. Если такого элемента нет, то объект считается уникальным и он будет добавлен. Если элемент с таким же хеш-кодом уже есть, то дополнительно объекты сравниваются через equals. Это нужно, потому что хеш-коды не обязаны быть уникальными, то есть разные элементы могут иметь один хеш-код (такая ситуация называется коллизией). Поэтому нужно дополнительно проверить, равны ли объекты или нет. 


`LinkedHashSet` — это подкласс `HashSet`, который использует **хеш-таблицу** и **двусвязный список**. Его особенность в том, что он сохраняет порядок добавления элементов. При этом он использует больше памяти, чем `HashSet` для поддержания двусвязного списка. Время поиска, добавления и удаления элементов всё ещё в среднем константное.

Конструкторы `LinkedHashSet` такие же, как и у `HashSet`. Нам также необходимо переопределять методы `equals()` и `hashCode()`.
#### TreeSet

`TreeSet` основан на бинарном дереве поиска.  Его особенность заключается в том, что элементы множества сортируются.  Для этого используется [компараторы](#). Для стандартных типов (Integet, String, Double и др.) компараторы определены, но для того, чтобы использовать свои типы необходимо реализовать компаратор самостоятельно. 

`TreeSet` реализует интерфейсы `Set`, `SortedSet` и `NavigableSet`.

Методы SortedSet:
- `E first()`: возвращает первый элемент набора
- `E last()`: возвращает последний элемент набора
- `SortedSet<E> headSet(E end)`: возвращает объект SortedSet, который содержит все элементы начала набора до элемента end
- `SortedSet<E> subSet(E start, E end)`: возвращает объект SortedSet, который содержит все элементы первичного набора между элементами start и end
- `SortedSet<E> tailSet(E start)`: возвращает объект SortedSet, который содержит все элементы первичного набора, начиная с элемента start

NavigableSet определяет следующие методы:

- `E ceiling(E obj)`: ищет в наборе наименьший элемент e, который больше obj (e >=obj). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается null.
- `E floor(E obj)`: ищет в наборе наибольший элемент e, который меньше элемента obj (e <=obj). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается null.
- `E higher(E obj)`: ищет в наборе наименьший элемент e, который больше элемента obj (e >obj). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается null.
- `E lower(E obj)`: ищет в наборе наибольший элемент e, который меньше элемента obj (e <obj). Если такой элемент найден, то он возвращается в качестве результата. Иначе возвращается null.
- `E pollFirst()`: возвращает первый элемент и удаляет его из набора
- `E pollLast()`: возвращает последний элемент и удаляет его из набора
- `NavigableSet<E> descendingSet()`: возвращает объект NavigableSet, который содержит все элементы первичного набора NavigableSet в обратном порядке
- `NavigableSet<E> headSet(E upperBound, boolean incl)`: возвращает объект NavigableSet, который содержит все элементы первичного набора NavigableSet до upperBound. Параметр incl при значении true, позволяет включить в выходной набор элемент upperBound
- `NavigableSet<E> tailSet(E lowerBound, boolean incl)`: возвращает объект NavigableSet, который содержит все элементы первичного набора NavigableSet, начиная с lowerBound. Параметр incl при значении true, позволяет включить в выходной набор элемент lowerBound
- `NavigableSet<E> subSet(E lowerBound, boolean lowerIncl, E upperBound, boolean highIncl)`: возвращает объект NavigableSet, который содержит все элементы первичного набора NavigableSet от lowerBound до upperBound.

Конструкторы:
- `TreeSet()`: создает пустое множество
- `TreeSet(Collection<? extends E> col)`: создает множество с элементами из коллекции col
- `TreeSet(SortedSet <E> set)`: создает множество, в которое добавляет все элементы сортированного набора set
- `TreeSet(Comparator<? super E> comparator)`: создает пустое множество, где все добавляемые элементы впоследствии будут отсортированы [компаратором]().

`TreeSet` менее эффективная реализация, чем множества на основе хеш-таблиц, так как нужно поддерживать сортировку.

#### Сравнение

| Характеристика                                      | HashSet          | LinkedHashSet                   | TreeSet                               |
| --------------------------------------------------- | ---------------- | ------------------------------- | ------------------------------------- |
| Внутренняя структура                                | Хеш-таблица      | Хеш-таблица и двусвязный список | Бинарное дерево поиска                |
| Порядок элементов                                   | Не гарантируется | В порядке добавления элементов  | Согласно компаратору                  |
| Только уникальные элементы                          | +                | +                               | +                                     |
| Производительность                                  | Самый эфективный | Менее эффективный по памяти     | Менее эффективный по памяти и времени |
| Реализуемые интерфейсы                              | `Set`            | `Set`                           | `Set`, `SortedSet`, `NavigableSet`    |
| Необходимость переопределения `equals` и `hashCode` | +                | +                               | -                                     |

___

### 26. Что такое HashMap и TreeMap? В чём их различие?

`HashMap`, `LinkedHashMap` и `TreeMap` — это  реализации интерфейса `Map` в Java. Они используются для хранения данных в виде пар "ключ-значение" (словарь, карта, отображение), но отличаются внутренней структурой, порядком хранения элементов и производительностью.

Методы интерфейса `Map`:

- `void clear()`: очищает коллекцию
- `boolean containsKey(Object k)`: возвращает true, если коллекция содержит ключ k
- `boolean containsValue(Object v)`: возвращает true, если коллекция содержит значение v
- `Set<Map.Entry<K, V>> entrySet()`: возвращает набор элементов коллекции. Все элементы представляют объект `Map.Entry`
- `boolean equals(Object obj)`: возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
- `boolean isEmpty`: возвращает true, если коллекция пуста
- `V get(Object k)`: возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение `null`
- `V getOrDefault(Object k, V defaultValue)`: возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение `defaultVlue`
- `V put(K k, V v)`: помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение `null`
- `V putIfAbsent(K k, V v)`: помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
- `Set<K> keySet()`: возвращает набор всех ключей отображения
- `Collection<V> values()`: возвращает набор всех значений отображения
- `void putAll(Map<? extends K, ? extends V> map)`: добавляет в коллекцию все объекты из отображения map
- `V remove(Object k)`: удаляет объект с ключом k
- `int size()`: возвращает количество элементов коллекции

Интерфейс `Map` имеет внутренний интерфейс `Entry<K, V>`, который используется во многих методах и представляет собой одну запись из словаря (пара ключ типа K и значение типа V). Методы `Entry<K, V>`:
- `boolean equals(Object obj)`: возвращает true, если объект obj, представляющий интерфейс `Map.Entry`, идентичен текущему
- `K getKey()`: возвращает ключ объекта отображения
- `V getValue()`: возвращает значение объекта отображения
- `V setValue(V v)`: устанавливает для текущего объекта значение v
- `int hashCode()`: возвращает хеш-код данного объекта
#### HashMap и LinkedHashMap

`HashMap` основан на **хэш-таблице**. Он использует хэш-коды ключей для быстрого доступа и хранения данных.

По сути множество ключей `HashMap` полностью аналогично `HashSet` (хотя, технически именно `HashSet` реализован через `HashMap`).  Это значит, что все утверждения про `HashSet` верны и для множества ключей `HashMap`: дубликаты запрещены, порядок не гарантируется, константное время поиска, добавления и удаления элементов, необходимость переопределения `equals()` и `hashCode()`.

Аналогично, `LinkedHashMap` соответствует `LinkedHashSet` и множество его ключей имеет те же свойства.

Конструкторы `HashMap` и `LinkedHashMap` (они аналогичны):
+ new HashMap<>(); - создаёт пустой словарь
+ new HashMap<>(int initialCapacity); - создает пустой словарь с указанной начальной емкостью
+ new HashMap<>(int initialCapacity, float loadFactor); - создает пустой словарь с указанной начальной емкостью и коэффициентом загрузки.
+ new HashMap<>(Map\<? extends K, ? extends V> m); - создает словарь с элементами другого словаря.
#### TreeMap

Множество ключей `TreeMap` также аналогично `TreeSet` и имеет те же свойства: основано на бинарном дереве поиска, сортировка на основе [компаратора](#), менее эффективно чем другие реализации.

Класс `TreeMap` реализует интерфейсы `SortedMap` и `NavgableMap`.

Методы `SortedMap`:
- `K firstKey()`: возвращает ключ первого элемента отображения
- `K lastKey()`: возвращает ключ последнего элемента отображения
- `SortedMap<K, V> headMap(K end)`: возвращает отображение SortedMap, которые содержит все элементы оригинального SortedMap вплоть до элемента с ключом end
- `SortedMap<K, V> tailMap(K start)`: возвращает отображение SortedMap, которые содержит все элементы оригинального SortedMap, начиная с элемента с ключом start
- `SortedMap<K, V> subMap(K start, K end)`: возвращает отображение SortedMap, которые содержит все элементы оригинального SortedMap вплоть от элемента с ключом start до элемента с ключом end

Методы `NavigableMap`:
- `Map.Entry<K, V> ceilingEntry(K key)`: возвращает элемент с наименьшим ключом k, который больше или равен ключу key (k >=key). Если такого ключа нет, то возвращается null.
- `Map.Entry<K, V> floorEntry(K key)`: возвращает элемент с наибольшим ключом k, который меньше или равен ключу key (k <=key). Если такого ключа нет, то возвращается null.
- `Map.Entry<K, V> higherEntry(K key)`: возвращает элемент с наименьшим ключом k, который больше ключа key (k >key). Если такого ключа нет, то возвращается null.
- `Map.Entry<K, V> lowerEntry(K key)`: возвращает элемент с наибольшим ключом k, который меньше ключа key (k <key). Если такого ключа нет, то возвращается null.
- `Map.Entry<K, V> firstEntry()`: возвращает первый элемент отображения
- `Map.Entry<K, V> lastEntry()`: возвращает последний элемент отображения
- `Map.Entry<K, V> pollFirstEntry()`: возвращает и одновременно удаляет первый элемент из отображения
- `Map.Entry<K, V> pollLastEntry()`: возвращает и одновременно удаляет последний элемент из отображения
- `K ceilingKey(K key)`: возвращает наименьший ключ k, который больше или равен ключу key (k >=key). Если такого ключа нет, то возвращается null.
- `K floorKey(K key)`: возвращает наибольший ключ k, который меньше или равен ключу key (k <=key). Если такого ключа нет, то возвращается null.
- `K lowerKey(K key)`: возвращает наибольший ключ k, который меньше ключа key (k <key). Если такого ключа нет, то возвращается null.
- `K higherKey(K key)`: возвращает наименьший ключ k, который больше ключа key (k >key). Если такого ключа нет, то возвращается null.
- `NavigableSet<K> descendingKeySet()`: возвращает объект NavigableSet, который содержит все ключи отображения в обратном порядке
- `NavigableMap<K, V> descendingMap()`: возвращает отображение NavigableMap, которое содержит все элементы в обратном порядке
- `NavigableSet<K> navigableKeySet()`: возвращает объект NavigableSet, который содержит все ключи отображения
- `NavigableMap<K, V> headMap(K upperBound, boolean incl)`: возвращает отображение NavigableMap, которое содержит все элементы оригинального NavigableMap вплоть от элемента с ключом upperBound. Параметр incl при значении true указывает, что элемент с ключом upperBound также включается в выходной набор.
- `NavigableMap<K, V> tailMap(K lowerBound, boolean incl)`: возвращает отображение NavigableMap, которое содержит все элементы оригинального NavigableMap, начиная с элемента с ключом lowerBound. Параметр incl при значении true указывает, что элемент с ключом lowerBound также включается в выходной набор.
- `NavigableMap<K, V> subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl)`: возвращает отображение NavigableMap, которое содержит все элементы оригинального NavigableMap от элемента с ключом lowerBound до элемента с ключом upperBound. Параметры lowIncl и highIncl при значении true включают в выходной набор элементы с ключами lowerBound и upperBound соответственно.

Конструкторы `TreeMap`:

- `TreeMap()`: создает пустой словарь
- `TreeMap(Map<? extends K,​? extends V> map)`: создает словарь с элементами из другого словаря
- `TreeMap(SortedMap<K, ? extends V> smap)`: создаёт словарь с элементами другого сортированного словаря    
- `TreeMap(Comparator<? super K> comparator)`: создает пустой словарь, где все добавляемые элементы впоследствии будут отсортированы [компаратором](#).
#### Сравнение

| Характеристика                                                        | HashMap                                                       | LinkedHashMap                                                | TreeMap                                                  |
| --------------------------------------------------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| Внутренняя структура                                                  | Хеш-таблица                                                   | Хеш-таблица и двусвязный список                              | Бинарное дерево поиска                                   |
| Порядок ключей                                                        | Не гарантируется                                              | В порядке добавления элементов                               | Согласно компаратору                                     |
| Производительность                                                    | Самый эфективный                                              | Менее эффективный по памяти                                  | Менее эффективный по памяти и времени                    |
| Null                                                                  | Разрешает один ключ `null` и любое количество значений `null` | Разрешает один ключ `null` и любое количество значений `null | Не разрешает ключи `null`, но значения могут быть `null` |
| Реализуемые интерфейсы                                                | `Map`                                                         | `Map`                                                        | `Map`, `SortedMap`, `NavigableMap`                       |
| Необходимость переопределения `equals` и `hashCode` для класса ключей | +                                                             | +                                                            | -                                                        |
___

### 27. Что такое итератор в Java и как его использовать?

**Итератор (Iterator)** в Java — это объект, который предоставляет возможность последовательно обходить элементы коллекции. Изначально итератор не указывает ни на какой элемент и с помощью метода `next()` мы можем передвигаться по элементам коллекции. 

Методы:
+ `E next()` - возвращает следующий элемент коллекции
+ `boolean hasNext()` - возвращает `true`, если в коллекции есть следующий элемент. Иначе возвращает `false`
+ `void remove()` – удаляет элемент на позиции итератора.

Пример использования итератора:
```java
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Cherry");

// Получаем итератор
Iterator<String> iterator = list.iterator();

// Обходим элементы с помощью итератора
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

Помимо интерфейса `Iterator` существует интерфейс `ListIterator` , который может использоваться со всеми коллекциями, реализующими интерфейс `List`.

Методы ListIterator (помимо тех, что есть и в `Iterator` ):
+ `void add(E obj)`: вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом `next()`
- `boolean hasPrevious()`: возвращает `true`, если в коллекции имеется предыдущий элемент, иначе возвращает false
- `E previous()`: возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение `NoSuchElementException`
- `int nextIndex()`: возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка
- `int previousIndex()`: возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1
- `void set(E obj)`: присваивает текущему элементу, выбранному вызовом методов `next()` или `previous()`, ссылку на объект `obj`

___
### 28. Что такое сортировка в коллекциях и какие методы сортировки существуют?

**Сортировка в коллекциях** — это процесс упорядочивания элементов коллекции (например, списка, множества) в определённом порядке (по возрастанию, убыванию или по заданному критерию). В Java сортировка может быть выполнена как для примитивных типов, так и для объектов.

Методы сортировки коллекций в Java:
+ `Collections.sort()`
```java
List<Integer> numbers = new ArrayList<>();
numbers.add(5);
numbers.add(1);
numbers.add(3);

Collections.sort(numbers); // Сортировка по возрастанию
Collections.sort(numbers, Collections.reverseOrder()); // Сортировка по убыванию
```
+ `List.sort()`
```java
List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");
names.add("Charlie");

names.sort(Comparator.naturalOrder()); // Сортировка по возрастанию
```
+ Сортировка с использованием [`Comparable`](#)
```java
class Person implements Comparable<Person> {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return this.age - other.age; // Сортировка по возрасту
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 25));
        people.add(new Person("Bob", 30));
        people.add(new Person("Charlie", 20));

        Collections.sort(people); // Используется compareTo
    }
}
```
+ Stream API (Java 8+)
```java
List<String> sortedNames = names.stream()
    .sorted() // Сортировка по возрастанию
    .toList();
```

> Java использует алгоритм сортировки **TimSort** (гибридный алгоритм, основанный на сортировке слиянием и вставками). Вообще алгоритмы вряд ли будут спрашивать, но если спросят то вот несколько самых известных алгоритмов сортировки:

> Быстрая сортировка (quick sort) - в середине списка выбирается элемент (опорный). Все б**о**льшие элементы ставятся до этого элемента, все меньшие - после. Те же операции рекурсивно выполняются для подсписков слева от опорного элемента  и справа от него, пока список не будет отсортирован.

> Сортировка пузырьком (bubble sort) - в цикле попарно сравниваются элементы и переставляются местами если они идут в неправильном порядке. С каждой итерацией как минимум один элемент (максимальный) становится на своё место (в конце списка). Есть улучшенная версия алгоритма - шейкерная сортировка. Итерации проходят не только с начала в конец, но и с конца в начало (после итерации минимальный и максимальный элемент становятся на свои места)

> Сортировка выбором (selection sort). В цикле находится минимальный элемент списка и ставится в начало. Потом следующий минимальный элемент на вторую позицию и т.д.

>Сортировка вставками (insertion sort). В цикле перебираются элементы. Рассматриваемый элемент вставляется в начало списка в нужное место, таким образом в начале списка образуется отсортированная последовательность. Элементы вставляются до тех пор, пока список не будет отсортирован

